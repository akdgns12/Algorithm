package DFS_BFS;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

public class 위클리챌린지9주차 {
	// 프로그래머스 위클리 챌린지9주차 / 2020네이버 하반기 2번 유사문제 / 그래프 탐색
	/*
	 * 우선 문제를 보면 연결, 즉 간선이 n-1개이고, 하나의 트리로 되어있다고 되어있기 때문에 계산해보면 
	 * 하나의 전선을 제거했을 때 무조건 두 개의 트리로 나누어진다는 것을 알고 문제 풀이를 시작한다. 
	 * 따라서 나는 각 전선들을 모두 끊어보고 나뉘어진 두 트리 중 하나의 트리를 BFS로 탐색하며 노드의 수를 구해서 
	 * n을 이용해서 나머지 트리의 노드 수도 구하고, 두 값의 차를 구해보려고 한다. 그리고 그 중에서 가장 작은 값을 반환할 것이다 !
	       먼저 입력값을 토대로 그래프를 구성해주었다. 나는 이차원 배열 형태로 연결된 노드들을 표현해주었다.
	       그리고 입력으로 주어진 연결된 노드들, wires를 탐색하면서 해당 전선을 끊는 경우에 대해서 탐색을 해주었다. 
	       즉 1-2를 끊는다면 1을 기준으로 BFS 탐색을 시작하는데, 2로는 탐색을 진행하지 않도록 방문 조건을 하나 더 걸어주었다. 
	       탐색을 진행하면서 노드의 수를 카운팅해주었다. 
	       그러면 카운팅 결과를 바탕으로 두 개로 나뉘어진 트리들의 노드 수의 차를 구할 수 있고, 
	       더 작은 값들이 나올때마다 갱신해주었다.
	 */
	static int[] parent;
	
	public int solution(int n, int[][] wires) {
		int answer = 0;
		
		
		
		return answer;
	}
}
